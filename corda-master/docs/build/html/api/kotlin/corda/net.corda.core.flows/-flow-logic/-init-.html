<HTML>
<HEAD>
<meta charset="UTF-8">
<title>FlowLogic.<init> - corda</title>
<link rel="stylesheet" href="../../../style.css">
</HEAD>
<BODY>
<a href="../../index.html">corda</a>&nbsp;/&nbsp;<a href="../index.html">net.corda.core.flows</a>&nbsp;/&nbsp;<a href="index.html">FlowLogic</a>&nbsp;/&nbsp;<a href=".">&lt;init&gt;</a><br/>
<br/>
<h1>&lt;init&gt;</h1>
<code><span class="identifier">FlowLogic</span><span class="symbol">(</span><span class="symbol">)</span></code>
<p>A sub-class of <a href="index.html">FlowLogic</a> implements a flow using direct, straight line blocking code. Thus you
can write complex flow logic in an ordinary fashion, without having to think about callbacks, restarting after
a node crash, how many instances of your flow there are running and so on.</p>
<p>Invoking the network will cause the call stack to be suspended onto the heap and then serialized to a database using
the Quasar fibers framework. Because of this, if you need access to data that might change over time, you should
request it just-in-time via the <a href="service-hub.html">serviceHub</a> property which is provided. Don't try and keep data you got from a
service across calls to send/receive/sendAndReceive because the world might change in arbitrary ways out from
underneath you, for instance, if the node is restarted or reconfigured!</p>
<p>Additionally, be aware of what data you pin either via the stack or in your <a href="index.html">FlowLogic</a> implementation. Very large
objects or datasets will hurt performance by increasing the amount of data stored in each checkpoint.</p>
<p>If you'd like to use another FlowLogic class as a component of your own, construct it on the fly and then pass
it to the <a href="sub-flow.html">subFlow</a> method. It will return the result of that flow when it completes.</p>
</BODY>
</HTML>
